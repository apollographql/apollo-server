---
title: Error handling
description: Making errors actionable on the client and server
---

<!-- cSpell:ignore typenam -->

Whenever Apollo Server encounters errors while processing a GraphQL operation, its response to the client includes an `errors` array containing each error that occurred. Each error in the array has an `extensions` field that provides additional useful information, including an error `code` and (while in development mode) an `exception.stacktrace`.

Here's an example error response caused by misspelling the `__typename` field in a query:

<ExpansionPanel title="Click to expand">

```json
{
  "errors": [
    {
      "message": "Cannot query field \"__typenam\" on type \"Query\".",
      "locations": [
        {
          "line": 1,
          "column": 2
        }
      ],
      "extensions": {
        "code": "GRAPHQL_VALIDATION_FAILED",
        "exception": {
          "stacktrace": [
            "GraphQLError: Cannot query field \"__typenam\" on type \"Query\".",
            "    at Object.Field (/my_project/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js:48:31)",
            "    ...additional lines..."
          ]
        }
      }
    }
  ]
}
```

</ExpansionPanel>

To help with debugging, Apollo Server provides an `ApolloServerErrorCode` enum, which you can use to check if your error is one of the [different types recognized by Apollo Server](#error-codes).

If Apollo Server recognizes your error type, you can write custom logic to handle that error, like so:

```ts
import { ApolloServerErrorCode } from '@apollo/server/errors';

if (error.extensions?.code === ApolloServerErrorCode.GRAPHQL_PARSE_FAILED) {
  // respond to the syntax error
}
```

Apollo Server's variety of error codes enables requesting clients to respond differently to different error types. You can also [create your own custom errors and codes](#custom-errors).

## Error codes

<table class="field-table">
  <thead>
    <tr>
      <th>Code</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>

<tr>
<td>

###### `GRAPHQL_PARSE_FAILED`

</td>
<td>

The GraphQL operation string contains a syntax error.

</td>
</tr>

<tr>
<td>

###### `GRAPHQL_VALIDATION_FAILED`

</td>
<td>

The GraphQL operation is not valid against the server's schema.

</td>
</tr>

<tr>
<td>

###### `BAD_USER_INPUT`

</td>
<td>

The GraphQL operation includes an invalid value for a field argument.

</td>
</tr>

<tr>
<td>

###### `PERSISTED_QUERY_NOT_FOUND`

</td>
<td>

A client sent the hash of a query string to execute via [automatic persisted queries](/apollo-server/performance/apq/), but the query was not in the APQ cache.

</td>
</tr>

<tr>
<td>

###### `PERSISTED_QUERY_NOT_SUPPORTED`

</td>
<td>

A client sent the hash of a query string to execute via [automatic persisted queries](/apollo-server/performance/apq/), but the server has disabled APQ.

</td>
</tr>

<tr>
<td>

###### `OPERATION_RESOLUTION_FAILURE`

</td>
<td>

The request was parsed successfully and is valid against the server's schema, but the server couldn't resolve which operation to run.

This occurs when a request containing multiple named operations doesn't specify which operation to run, or if the operation specified isn't included in the request.

</td>
</tr>

<tr>
<td>

###### `BAD_REQUEST`

</td>
<td>

An error occurred before your server could attempt to parse the given GraphQL operation.

</td>
</tr>

<tr>
<td>

###### `INTERNAL_SERVER_ERROR`

</td>
<td>

An unspecified error occurred.

This is the default error code returned when Apollo Server doesn't specify a different code.

</td>
</tr>

</tbody>
</table>

## Custom errors

You can create a custom errors and codes using the `graphql` package's `GraphQLError` class, like so:

```ts
import { GraphQLError } from 'graphql';

throw new GraphQLError(message, {
  extensions: { code: 'YOUR_ERROR_CODE', myCustomExtensions },
});
```

Custom errors can provide additional context, enabling your clients to understand _why_ an error is happening. We recommend making clear errors for common cases, for example, when a user isn't logged in (`UNAUTHENTICATED`), or someone is forbidden from performing an action:

```ts
import { GraphQLError } from 'graphql';

throw new GraphQLError('You are not authorized to perform this action.', {
  extensions: {
    code: 'FORBIDDEN',
  },
});
```

## Throwing errors

Apollo Server throws [errors](#error-codes) automatically when applicable. For example, it throws a `GRAPHQL_VALIDATION_FAILED` error whenever an incoming operation isn't valid against the server's schema.

Your resolvers can also throw errors in situations where Apollo Server doesn't do so automatically.

For example, this resolver throws a [custom error](#custom-errors) if the integer value provided for a user's ID is less than `1`:

<ExpansionPanel title="Click to expand">

```ts
import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone';
import { GraphQLError } from 'graphql';

const typeDefs = `#graphql
  type Query {
    userWithID(id: ID!): User
  }

  type User {
    id: ID!
    name: String!
  }
`;

const resolvers = {
  Query: {
    userWithID: (_, args) => {
      // highlight-start
      if (args.id < 1) {
        throw new GraphQLError('Invalid argument value', {
          extensions: {
            code: 'BAD_USER_INPUT',
          },
        });
      } // highlight-end
      // ...fetch correct user...
    },
  },
};
```

</ExpansionPanel>

If a resolver throws a generic error that is _not_ a `GraphQLError` instance, that error is still thrown with an `extensions` field that includes a `stacktrace` and `code` (specifically [`INTERNAL_SERVER_ERROR`](#internal_server_error)), along with any other relevant error details.

### Including custom error details

Whenever you throw a `GraphQLError`, you can add arbitrary fields to the error's `extensions` object to provide additional context to the client. You specify these fields in an object you provide to the error's constructor.

This example builds on the one above by adding the name of the GraphQL argument that was invalid:

<ExpansionPanel title="Click to expand">

```js
import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone';
import { GraphQLError } from 'graphql';

const typeDefs = `#graphql
  type Query {
    userWithID(id: ID!): User
  }

  type User {
    id: ID!
    name: String!
  }
`;

const resolvers = {
  Query: {
    userWithID: (_, args) => {
      if (args.id < 1) {
        throw new GraphQLError('Invalid argument value', {
          // highlight-start
          extensions: {
            code: 'BAD_USER_INPUT',
            argumentName: 'id',
          },
          // highlight-end
        });
      }
      // ...fetch correct user...
    },
  },
};
```

</ExpansionPanel>

This results in a response like the following:

<ExpansionPanel title="Click to expand">

```json
{
  "errors": [
    {
      "message": "Invalid argument value",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": ["userWithID"],
      "extensions": {
        "code": "BAD_USER_INPUT",
        // highlight-start
        "argumentName": "id",
        // highlight-end
        "exception": {
          "stacktrace": [
            "GraphQLError: Invalid argument value",
            "    at userWithID (/my-project/index.js:25:13)",
            "    ...more lines..."
          ]
        }
      }
    }
  ]
}
```

</ExpansionPanel>

## Omitting or including `stacktrace`

The `exception.stacktrace` error field is useful while developing and debugging your server, but you probably don't want to expose it to clients in production.

By default, Apollo Server _omits_ the `exception.stacktrace` field if the `NODE_ENV` environment variable is set to either `production` or `test`.

<!-- TODO(AS4) link to API docs for includeStackTracesInErrorResponses -->

You can override this default behavior by passing the `includeStackTracesInErrorResponses` option to the constructor of `ApolloServer`. If `includeStackTracesInErrorResponses` is `true`, `exception.stacktrace` is always included. If it's `false`, `exception.stacktrace` is always omitted.

Note that when `exception.stacktrace` is omitted, it's also unavailable to your application. To log error `stacktrace`s without including them in responses to clients, see [Masking and logging errors](#masking-and-logging-errors).

## Masking and logging errors

You can edit Apollo Server error details before they're passed to a client or reported to Apollo Studio. This enables you to omit sensitive or irrelevant data.

### For client responses

The `ApolloServer` constructor accepts a `formatError` hook that is run on each error before it's passed back to the client. You can use this function to log or mask particular errors.

The `formatError` hook receives two arguments: the first is the error formatted as a JSON object (to be spent with the response), and the second is the original error.

> The `formatError` function does _not_ modify errors that are sent to Apollo Studio as part of usage reporting. See [For Apollo Studio reporting](#for-apollo-studio-reporting).

The below example returns a user-friendly message whenever Apollo Server throws a `GRAPHQL_VALIDATION_FAILED` error:

```ts
import { ApolloServerErrorCode } from '@apollo/server/errors';

const server = new ApolloServer({
  typeDefs,
  resolvers,
  // highlight-start
  formatError: (formattedError, error) => {
    // Return a different error message
    if (
      formattedError.extensions.code ===
      ApolloServerErrorCode.GRAPHQL_VALIDATION_FAILED
    ) {
      return {
        ...formattedError,
        message: "Your query doesn't match the schema. Try double-checking it!",
      };
    }

    // Otherwise return the formatted error. This error can also
    // be manipulated in other ways, as long as it's returned.
    return formattedError;
  },
  // highlight-end
});

const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });

console.log(`ðŸš€ Server listening at: ${url}`);
```

As another example, here we return a more generic error whenever the original error's message begins with `Database Error: `:

```ts
formatError: (formattedError, error) => {
  // highlight-start
  if (formattedError.message.startsWith('Database Error: ')) {
    return { message: 'Internal server error' };
  }
  // highlight-end

  // Otherwise return the formatted error.
  return formattedError;
},
```

> To make context-specific adjustments to the error received by `formatError` (such as localization or personalization), consider [creating a plugin](/apollo-server/integrations/plugins/) that uses the [`didEncounterErrors` lifecycle event](/apollo-server/integrations/plugins-event-reference/#didencountererrors) to attach additional properties to the error. These properties can be accessed from `formatError`.

### For Apollo Studio reporting

You can use Apollo Studio to analyze your server's error rates. If you connect Apollo Server to Studio, all errors are sent to Studio by default. If you _don't_ want certain error information to be sent to Studio (either because the error is unimportant or because certain information is confidential), you can modify or redact errors entirely before they're transmitted.

To accomplish this, you can provide a `rewriteError` function to the [usage reporting plugin](/apollo-server/api/plugin/usage-reporting/).

<!-- TODO(AS4) is this still true? -->

> The usage reporting plugin is installed automatically with its default configuration if you provide an Apollo API key to Apollo Server. To define a custom `rewriteError` function, you need to install the plugin explicitly with a custom configuration, as shown in examples below.

Your `rewriteError` function is called for each error (`GraphQLError`) to be reported to Studio. The error is provided as the function's first argument. The function can either:

- Return a modified form of the error (e.g., by changing the `err.message` to remove potentially sensitive information)
- Return `null` to prevent the error from being reported entirely

> **For federated graphs**, instead define `rewriteError` in each subgraph's [inline trace plugin](/apollo-server/api/plugin/inline-trace/#rewriteerror). Do not define it in the gateway.

#### Example: Ignoring common low-severity errors

Let's say our server is `throw`ing an `UNAUTHENTICATED` error whenever a user enters an incorrect password. We can avoid reporting these errors to Apollo Studio by defining `rewriteError`, like so:

```ts
import { ApolloServer } from '@apollo/server';
import { ApolloServerPluginUsageReporting } from '@apollo/server/plugin/usageReporting';

const server = new ApolloServer({
  typeDefs,
  resolvers,
  plugins: [
    // highlight-start
    ApolloServerPluginUsageReporting({
      rewriteError(err) {
        // Return `null` to avoid reporting `UNAUTHENTICATED` errors
        if (err.extensions.code === 'UNAUTHENTICATED') {
          return null;
        }

        // All other errors will be reported.
        return err;
      },
    }),
    // highlight-end
  ],
});
```

This example configuration ensures that any `UNAUTHENTICATED` error that's thrown within a resolver is only reported to the client, and never sent to Apollo Studio. All other errors are transmitted to Studio normally.

#### Example: Filtering errors based on other properties

When generating an error (e.g., `new GraphQLError("Failure!")`), the error's `message` is the most common property (in this case it's `Failure!`). However, any number of properties can be attached to the error (such as a `code` property).

We can check these properties when determining whether an error should be reported to Apollo Studio using the `rewriteError` function as follows:

```ts
import { ApolloServer } from '@apollo/server';
import { ApolloServerPluginUsageReporting } from '@apollo/server/plugin/usageReporting';

const server = new ApolloServer({
  typeDefs,
  resolvers,
  plugins: [
    ApolloServerPluginUsageReporting({
      rewriteError(err) {
        // Using a more stable, known error property (e.g. `err.code`) would be
        // more defensive, however checking the `message` might serve most needs!
        // highlight-start
        if (err.message && err.message.startsWith('Known error message')) {
          return null;
        }
        // highlight-end

        // All other errors should still be reported!
        return err;
      },
    }),
  ],
});
```

This example configuration ensures that any error that starts with `Known error message` is not transmitted to Apollo Studio, but all other errors are sent as normal.

#### Example: Redacting the error message

If it is necessary to change an error prior to reporting it to Apollo Studio (for example, if there is personally identifiable information in the error `message`), the `rewriteError` function can also help.

Consider an example where the error contains a piece of information like an API key:

```js
import { GraphQLError } from 'graphql';

throw new GraphQLError(
  "The x-api-key:12345 doesn't have sufficient privileges.",
);
```

The `rewriteError` function can ensure that such information is not sent to Apollo Studio and potentially revealed outside its intended scope:

```ts
import { ApolloServer } from '@apollo/server';
import { ApolloServerPluginUsageReporting } from '@apollo/server/plugin/usageReporting';

const server = new ApolloServer({
  typeDefs,
  resolvers,
  plugins: [
    ApolloServerPluginUsageReporting({
      // highlight-start
      rewriteError(err) {
        // Make sure that a specific pattern is removed from all error messages.
        err.message = err.message.replace(/x-api-key:[A-Z0-9-]+/, 'REDACTED');
        return err;
      },
      // highlight-end
    }),
  ],
});
```

In this case, the error above is reported to Apollo Studio as:

```
The REDACTED doesn't have sufficient privileges.
```

## Returning HTTP status codes

GraphQL, by design, does not use the same conventions from REST to communicate via HTTP verbs and status codes. Client information should be contained in the schema or as part of the standard response `errors` field. We recommend using the included [Error Codes](#error-codes) or [Custom Errors](#custom-errors) for error consistency rather than directly modifying the HTTP response.

You can set custom fields on your HTTP response by using a [plugin](/apollo-server/integrations/plugins). Be aware that GraphQL client libraries may not treat all response status codes the same, and so it will be up to your team to decide what patterns to use.

As an example, here is how you could set a custom response header and status code based on a GraphQL error:

```ts
const setHttpPlugin = {
  async requestDidStart() {
    return {
      async willSendResponse({ response }) {
        response.http.headers.set('Custom-Header', 'hello');
        if (response?.errors?.[0]?.message === 'teapot') {
          response.http.status = 418;
        }
      },
    };
  },
};

const server = new ApolloServer({
  typeDefs,
  resolvers,
  plugins: [setHttpPlugin],
});
```
