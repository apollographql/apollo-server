---
title: File uploads
description: Enabling file uploads in Apollo Server
---

There are a few ways to accomplish file uploads in Apollo Server. Our [blog post](https://www.apollographql.com/blog/backend/file-uploads/file-upload-best-practices/) on file uploads goes in depth on the approaches we've taken, outlining the pros and cons of each.

Apollo recommends handling the file upload itself out-of-band of your GraphQL server for the sake of simplicity and security. This "signed URL" approach enables your client to retrieve a URL from your GraphQL server (via S3 or other storage service) and upload the file to the URL rather than to your GraphQL server. For details on how to set this up, see our [blog post](https://www.apollographql.com/blog/backend/file-uploads/file-upload-best-practices/).

Another common approach is to add file upload support directly to Apollo Server via the third-party [`graphql-upload`](https://npm.im/graphql-upload) library. This package provides support for the `multipart/form-data` content-type.

> ‚ö†Ô∏è This approach is vulnerable to a [CSRF mutation attacks](https://github.com/apollographql/apollo-server/security/advisories/GHSA-2p3c-p3qw-69r4) if you turn off Apollo Server 4's default CSRF Protection (e.g., passing `csrfPrevention: false` to your `ApolloServer` constructor).

The examples below show how to avoid a CSRF vulnerability by requiring a "preflight" `OPTIONS` request before executing an operation. When configuring your file upload client, you must send a non-empty `Apollo-Require-Preflight` header, or Apollo Server will block the request. For example, if you use the `apollo-upload-client` package with Apollo Client Web, you should pass the `{'Apollo-Require-Preflight': 'true'}` header to `createUploadLink`.

<!-- TODO:AS4 confirm if this is true -->

**New in Apollo Server 4:** The `startStandaloneServer` function doesn't support file uploads, you must use another Apollo Server 4 integration. This article shows how to integrate `graphql-upload` using Apollo Server 4's Express integration (i.e., `expressMiddleware`).

To implement similar functionality with another Node.js HTTP framework (e.g., Koa), see the [`graphql-upload` documentation](https://github.com/jaydenseric/graphql-upload) for more information. Note that some integrations might need to use `graphql-upload`'s `processRequest` directly.

### Integrating with Express

<MultiCodeBlock>

```ts title="index.ts"
import { ApolloServer } from '@apollo/server';
import { expressMiddleware } from '@apollo/server/express4';
import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import { finished } from 'stream/promises';
import GraphQLUpload from 'graphql-upload/GraphQLUpload.mjs';
import graphqlUploadExpress from 'graphql-upload/graphqlUploadExpress.mjs';

const typeDefs = `#graphql
  # The implementation for this scalar is provided by the
  # 'GraphQLUpload' export from the 'graphql-upload' package
  # in the resolver map below.
  scalar Upload

  type File {
    filename: String!
    mimetype: String!
    encoding: String!
  }

  type Query {
    # This is only here to satisfy the requirement that at least one
    # field be present within the 'Query' type.  This example does not
    # demonstrate how to fetch uploads back.
    otherFields: Boolean!
  }

  type Mutation {
    # Multiple uploads are supported. See graphql-upload docs for details.
    singleUpload(file: Upload!): File!
  }
`;

const resolvers = {
  // This maps the `Upload` scalar to the implementation provided
  // by the `graphql-upload` package.
  Upload: GraphQLUpload,

  Mutation: {
    singleUpload: async (_, { file }) => {
      const { createReadStream, filename, mimetype, encoding } = await file;

      // Invoking the `createReadStream` will return a Readable Stream.
      // See https://nodejs.org/api/stream.html#stream_readable_streams
      const stream = createReadStream();

      // This is purely for demonstration purposes and will overwrite the
      // local-file-output.txt in the current working directory on EACH upload.
      const out = require('fs').createWriteStream('local-file-output.txt');
      stream.pipe(out);
      await finished(out);

      return { filename, mimetype, encoding };
    },
  },
};

async function startServer() {
  const server = new ApolloServer({
    typeDefs,
    resolvers,
  });

  await server.start();
  const app = express();

  app.use(
    '/graphql',
    graphqlUploadExpress(),
    cors<cors.CorsRequest>(),
    bodyParser.json(),
    expressMiddleware(server),
  );

  await new Promise<void>((r) => app.listen({ port: 4000 }, r));

  console.log(`üöÄ Server ready at http://localhost:4000/graphql`);
}

startServer();
```

</MultiCodeBlock>

<!-- TODO(AS4) update once we have a stable fastify integration for folks
### Integrating with Fastify

```js
const { ApolloServer, gql } = require('apollo-server-fastify');
const {
  ApolloServerPluginLandingPageLocalDefault,
} = require('apollo-server-core');
const { GraphQLUpload, processRequest } = require('graphql-upload');
const { finished } = require('stream/promises');

const typeDefs = gql`
  # The implementation for this scalar is provided by the
  # 'GraphQLUpload' export from the 'graphql-upload' package
  # in the resolver map below.
  scalar Upload

  type File {
    filename: String!
    mimetype: String!
    encoding: String!
  }

  type Query {
    # This is only here to satisfy the requirement that at least one
    # field be present within the 'Query' type.  This example does not
    # demonstrate how to fetch uploads back.
    otherFields: Boolean!
  }

  type Mutation {
    # Multiple uploads are supported. See graphql-upload docs for details.
    singleUpload(file: Upload!): File!
  }
`;

const resolvers = {
  // This maps the `Upload` scalar to the implementation provided
  // by the `graphql-upload` package.
  Upload: GraphQLUpload,

  Mutation: {
    singleUpload: async (parent, { file }) => {
      const { createReadStream, filename, mimetype, encoding } = await file;

      // Invoking the `createReadStream` will return a Readable Stream.
      // See https://nodejs.org/api/stream.html#stream_readable_streams
      const stream = createReadStream();

      // This is purely for demonstration purposes and will overwrite the
      // local-file-output.txt in the current working directory on EACH upload.
      const out = require('fs').createWriteStream('local-file-output.txt');
      stream.pipe(out);
      await finished(out);

      return { filename, mimetype, encoding };
    },
  },
};

const app = require('fastify')({
  logger: true,
});

const start = async () => {
  try {
    // Handle all requests that have the `Content-Type` header set as multipart
    app.addContentTypeParser('multipart', (request, payload, done) => {
      request.isMultipart = true;
      done();
    });

    // Format the request body to follow graphql-upload's
    app.addHook('preValidation', async function (request, reply) {
      if (!request.isMultipart) {
        return;
      }

      request.body = await processRequest(request.raw, reply.raw);
    });

    const server = new ApolloServer({
      typeDefs,
      resolvers,
      // Using graphql-upload without CSRF prevention is very insecure.
      csrfPrevention: true,
      cache: 'bounded',
      plugins: [ApolloServerPluginLandingPageLocalDefault({ embed: true })],
    });

    // Start Apollo Server
    await server.start();

    app.register(server.createHandler());
    await app.listen(3000);
  } catch (err) {
    app.log.error(err);
    process.exit(1);
  }
};

start();
``` -->
