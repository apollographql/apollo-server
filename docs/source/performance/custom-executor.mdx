---
title: Using a Custom Executor
description: How to configure Apollo Server to use a custom executor
---

Apollo Server uses graphql-js behind the scenes when executing graphql queries.
If you would like to use a custom executor, such as
[graphql-jit](https://github.com/zalando-incubator/graphql-jit/tree/main),
you can swap in a `customExecutor`. This can result in significant performance
gains when used in combination with `staticOnly` cache control hints, especially with larger response sizes.

Note that this cannot be used when using the `gateway` option.

![graph showing how Apollo Server performance with increasing payload size with various setups](graphqlhit.png)

## Example using graphql-jit

```ts
import { compileQuery, isCompiledQuery } from 'graphql-jit';
import { lru } from 'tiny-lru';

const executor = (schema: GraphQLSchema, cacheSize = 2014, compilerOpts = {}) => {
  const cache = lru(cacheSize);
  return async ({ contextValue, document, operationName, request, queryHash }) => {
    const prefix = operationName || 'NotParametrized';
    const cacheKey = `${prefix}-${queryHash}`;
    let compiledQuery = cache.get(cacheKey);
    if (!compiledQuery) {
      const compilationResult = compileQuery(schema, document, operationName || undefined, compilerOpts);
      if (isCompiledQuery(compilationResult)) {
        compiledQuery = compilationResult;
        cache.set(cacheKey, compiledQuery);
      } else {
        // ...is ExecutionResult
        return compilationResult;
      }
    }

    return compiledQuery.query(undefined, contextValue, request.variables || {});
  };
};

const schema = buildSubgraphSchema([{ typeDefs, resolvers }]);

const server = new ApolloServer<BaseContext>({
  schema,
  customExecutor: executor(schema),
});
```
